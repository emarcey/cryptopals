# Cryptopals

Solutions for the [cryptopals](https://cryptopals.com/) problem set.

# Useful Links

## Python Resources

* [RealPython docs on Bitwise Ops](https://realpython.com/python-bitwise-operators/)
* [Python Crypto lib for AES implementation](https://docs.python.org/3/library/crypto.html)

## Other Solutions

Because I'm fallible and the internet is infinitely searchable. So if I got too stuck, I referenced a couple solutions.

* [ricpacca](https://github.com/ricpacca/cryptopals/)
* [Forging SHA1 Mac Length Extension Attack](https://www.synopsys.com/blogs/software-security/forging-sha-1-mac-using-length-extension-attack-python/)

## Wikipedia Articles

* [Block cipher encryption](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)
* [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister)
* [Base64 for encryption/decryption](https://en.wikipedia.org/wiki/Base64)
* [SHA-1](https://en.wikipedia.org/wiki/SHA-1)
* [Circular Shifts (left rotate)](https://en.wikipedia.org/wiki/Circular_shift)
* [HMAC](https://en.wikipedia.org/wiki/HMAC)
* [Diffie-Helman](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange)
* [Modular Exponentiation](https://en.wikipedia.org/wiki/Modular_exponentiation)
* [SRP](https://en.wikipedia.org/wiki/Secure_Remote_Password_protocol)
* [Primes to use for SRP](https://en.wikipedia.org/wiki/Safe_and_Sophie_Germain_primes)
* [Chinese Remainder Theorem](https://en.wikipedia.org/wiki/Chinese_remainder_theorem)

## Reference Material

* [ASCII character table](https://www.asciitable.com/)
* [Bae64 Table](https://en.wikipedia.org/wiki/Base64#Base64_table)
* [MD4 Algo](https://datatracker.ietf.org/doc/html/rfc1320)
* [Mode Exp implementation](https://rosettacode.org/wiki/Modular_exponentiation#Python)
* [Extended GCD](https://www.dcode.fr/extended-gcd)
* [invmod](https://www.dcode.fr/modular-inverse)